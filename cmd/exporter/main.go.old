package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/google/go-containerregistry/pkg/v1"
	"github.com/google/go-containerregistry/pkg/v1/mutate"

	"github.com/buildpack/packs"
	"github.com/buildpack/packs/img"
)

var (
	repoName   string
	stackName  string
	useDaemon  bool
	useHelpers bool
	launchDir  string
	appDir     string
)

func init() {
	// packs.InputDropletPath(&dropletPath)
	// packs.InputMetadataPath(&metadataPath)
	packs.InputStackName(&stackName)
	packs.InputUseDaemon(&useDaemon)
	packs.InputUseHelpers(&useHelpers)

	flag.StringVar(&launchDir, "launch", "/launch", "launch directory")
	flag.StringVar(&appDir, "app", "/launch/app", "app directory")
}

func main() {
	flag.Parse()
	repoName = flag.Arg(0)
	if flag.NArg() != 1 || repoName == "" || stackName == "" || launchDir == "" || appDir == "" {
		fmt.Println(flag.NArg() != 1, repoName == "", stackName == "", launchDir == "", appDir == "")
		fmt.Println(flag.NArg(), repoName, stackName, launchDir, appDir)
		packs.Exit(packs.FailCode(packs.CodeInvalidArgs, "parse arguments"))
	}
	packs.Exit(export())
}

func export() error {
	if useHelpers {
		if err := img.SetupCredHelpers(repoName, stackName); err != nil {
			return packs.FailErr(err, "setup credential helpers")
		}
	}

	newRepoStore := img.NewRegistry
	if useDaemon {
		newRepoStore = img.NewDaemon
	}
	repoStore, err := newRepoStore(repoName)
	if err != nil {
		return packs.FailErr(err, "access", repoName)
	}

	stackStore, err := img.NewRegistry(stackName)
	if err != nil {
		return packs.FailErr(err, "access", stackName)
	}
	stackImage, err := stackStore.Image()
	if err != nil {
		return packs.FailErr(err, "get image for", stackName)
	}

	tmpDir, err := ioutil.TempDir("", "pack.export.layer")
	if err != nil {
		return packs.FailErr(err, "create temp directory")
	}
	defer os.RemoveAll(tmpDir)

	var repoImage v1.Image
	dirs, err := filepath.Glob(filepath.Join(launchDir, "*", "*"))
	if err != nil {
		return packs.FailErr(err, "find launch layers")
	}

	repoImage = stackImage
	for idx, dir := range dirs {
		if fi, err := os.Stat(dir); err == nil && fi.IsDir() {
			if strings.HasPrefix(dir, filepath.Join(launchDir, "app")) {
				continue
			}
			// TODO look for [dir].toml (and place as label on layer)
			// TODO handle when only toml file exists (need to reuse layer)
			// TODO (should maybe use the fact it knows buildpack id ???)
			fmt.Println("Add layer:", dir)
			tarFile := filepath.Join(tmpDir, fmt.Sprintf("layer_%d.tgz", idx))
			if _, err := packs.Run("tar", "-czf", tarFile, dir); err != nil {
				defer os.Remove(tarFile)
				return packs.FailErr(err, "tar", dir, "to", tarFile)
			}
			repoImage, err = img.Append(repoImage, tarFile)
			if err != nil {
				return packs.FailErr(err, "append droplet to", stackName)
			}
		}
	}

	{
		dir := appDir
		fmt.Println("Add layer:", dir)
		tarFile := filepath.Join(tmpDir, "app.tgz")
		if _, err := packs.Run("tar", "-czf", tarFile, dir); err != nil {
			defer os.Remove(tarFile)
			return packs.FailErr(err, "tar", dir, "to", tarFile)
		}
		repoImage, err = img.Append(repoImage, tarFile)
		if err != nil {
			return packs.FailErr(err, "append droplet to", stackName)
		}
	}

	// TODO: do something real
	repoImage, err = StartCommand(repoImage, "/packs/launcher", "npm", "start")
	if err != nil {
		return packs.FailErr(err, "set start command")
	}

	stackDigest, err := stackImage.Digest()
	if err != nil {
		return packs.FailErr(err, "get digest for", stackName)
	}
	// TODO is this the correct metadata? (I took it from CF dir)
	var metadata packs.BuildMetadata
	metadata.Stack.Name = stackStore.Ref().Context().String()
	metadata.Stack.SHA = stackDigest.String()
	buildJSON, err := json.Marshal(metadata)
	if err != nil {
		return packs.FailErr(err, "get encode metadata for", repoName)
	}
	repoImage, err = img.Label(repoImage, packs.BuildLabel, string(buildJSON))
	if err != nil {
		return packs.FailErr(err, "label", repoName)
	}
	if err := repoStore.Write(repoImage); err != nil {
		return packs.FailErrCode(err, packs.CodeFailedUpdate, "write", repoName)
	}
	return nil
}

// TODO move this back to lib (somehow)
func StartCommand(image v1.Image, cmd ...string) (v1.Image, error) {
	configFile, err := image.ConfigFile()
	if err != nil {
		return nil, err
	}
	config := *configFile.Config.DeepCopy()
	config.Cmd = cmd
	return mutate.Config(image, config)
}
